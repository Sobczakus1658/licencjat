"""Custom sampler implementation matching DiscreteDDPPrecond architecture"""

import tqdm
import pickle
import numpy as np
import torch
import PIL.Image
import dnnlib

#----------------------------------------------------------------------------

def custom_generate_image_grid(
    network_pkl, dest_path,
    seed=0, gridw=8, gridh=8, device=torch.device('cuda'),
    num_steps=18, sigma_min=0.002, sigma_max=80, rho=7,
    S_churn=0, S_min=0, S_max=float('inf'), S_noise=1,
):
    batch_size = gridw * gridh
    torch.manual_seed(seed)

    # Load network.
    print(f'Loading network from "{network_pkl}"...')
    with dnnlib.util.open_url(network_pkl) as f:
        net = pickle.load(f)['ema'].to(device)

    # Pick latents and labels.
    print(f'Generating {batch_size} images...')
    latents = torch.randn([batch_size, net.img_channels, net.img_resolution, net.img_resolution], device=device)
    class_labels = None
    if net.label_dim:
        class_labels = torch.eye(net.label_dim, device=device)[torch.randint(net.label_dim, size=[batch_size], device=device)]

    # Adjust noise levels based on network constraints
    sigma_min = max(sigma_min, net.sigma_min)
    sigma_max = min(sigma_max, net.sigma_max)

    # Time step discretization
    step_indices = torch.arange(num_steps, dtype=torch.float64, device=device)
    t_steps = (sigma_max ** (1 / rho) + step_indices / (num_steps - 1) * (sigma_min ** (1 / rho) - sigma_max ** (1 / rho)) ** rho
    t_steps = torch.cat([net.round_sigma(t_steps), torch.zeros_like(t_steps[:1])])

    # Main sampling loop
    z = latents.to(torch.float64) * t_steps[0]
    
    for i, (t_cur, t_next) in tqdm.tqdm(list(enumerate(zip(t_steps[:-1], t_steps[1:]))), unit='step'):
        # Get current and next timestep indices
        t_idx_cur = net.sigma_to_t(t_cur)
        t_idx_next = net.sigma_to_t(t_next)
        
        # Get alpha and sigma values
        alpha_cur = net.alphas[t_idx_cur]
        alpha_next = net.alphas[t_idx_next]
        sigma_cur = t_cur
        sigma_next = t_next
        
        # Get eta from schedule
        eta_s = net.etas[t_idx_cur] if t_idx_cur < len(net.etas) else net.etas[-1]

        # Optional stochastic noise increase
        gamma = min(S_churn / num_steps, np.sqrt(2) - 1) if S_min <= t_cur <= S_max else 0
        t_hat = net.round_sigma(t_cur + gamma * t_cur)
        z_hat = z + (t_hat ** 2 - t_cur ** 2).sqrt() * S_noise * torch.randn_like(z)

        # Prepare network inputs (matching your forward())
        sigma_hat = t_hat.reshape(-1, 1, 1, 1).to(torch.float32)
        c_in = 1 / (net.sigma_data ** 2 + sigma_hat ** 2).sqrt()
        c_noise = sigma_hat.log() / 4

        # Get epsilon prediction
        model = net.module.model if hasattr(net, 'module') else net.model
        eps_pred = model((c_in * z_hat.to(torch.float32)).to(z_hat.dtype), 
                      c_noise.flatten(),
                      class_labels).to(torch.float64)

        # Custom update rule
        term1 = (sigma_next * torch.sqrt(1 - eta_s**2) - (alpha_next/alpha_cur)*sigma_cur) * eps_pred
        term2 = (alpha_next/alpha_cur) * z_hat
        noise_term = sigma_next * eta_s * torch.randn_like(z_hat)
        
        z = term1 + term2 + noise_term

    # Save image grid
    print(f'Saving image grid to "{dest_path}"...')
    image = (z * 127.5 + 128).clip(0, 255).to(torch.uint8)
    image = image.reshape(gridh, gridw, *image.shape[1:]).permute(0, 3, 1, 4, 2)
    image = image.reshape(gridh * net.img_resolution, gridw * net.img_resolution, net.img_channels)
    image = image.cpu().numpy()
    PIL.Image.fromarray(image, 'RGB' if net.img_channels == 3 else 'L').save(dest_path)
    print('Done.')

#----------------------------------------------------------------------------

def main():
    # Example usage with your trained model
    custom_generate_image_grid(
        'my_network/network.pkl',
        'custom_samples.png',
        num_steps=50,  # Can adjust for quality/speed tradeoff
        sigma_min=0.002,
        sigma_max=80,
        rho=7
    )

if __name__ == "__main__":
    main()